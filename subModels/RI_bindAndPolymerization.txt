function uniform(x,y)
(x+y)/2;
end

function fractionalPart(x)
  x - floor(x);
end

function mod(x,y)
   x - y * floor(x / y);
end

function minFunc(x,y)
  piecewise(x, x<y, y);
end

function maxFunc(x,y)
  piecewise(y, x<y, x);
end

function randInt(x)
  floor(uniform(0,1)*x);
end

function stochasticRound(x)
  piecewise(floor(x)+1.0, uniform(0,1)<fractionalPart(x), floor(x));
end

model RepInit_BindAndPolymerization()

compartment default;
species MG_469_1MER_ADP__bound in default, MG_469_1MER_ADP__c in default, MG_469_1MER_ATP__bound in default, MG_469_1MER_ATP__c in default;
var nAvo, kb1ATP, kb2ATP, cell_Volume, chromosome_R1, chromosmoe_R2, chromosome_R3, chromosome_R4;
var maxBindATP, numFreeDnaAATP;
var cSite, cState;

var Rx_free;
var Rx_1mer_ATP;
var Rx_1mer_ADP;
var Rx_2mer_ATP;
var Rx_2mer_ADP;
var Rx_3mer_ATP;
var Rx_3mer_ADP;
var Rx_4mer_ATP;
var Rx_4mer_ADP;
var Rx_5mer_ATP;
var Rx_5mer_ADP;
var Rx_6mer_ATP;
var Rx_6mer_ADP;
var Rx_7mer_ATP;
var Rx_7mer_ADP;

Rx_free = 0;
Rx_1mer_ADP = 1;
Rx_1mer_ATP = 2;
Rx_2mer_ADP = 3;
Rx_2mer_ATP = 4;
Rx_3mer_ADP = 5;
Rx_3mer_ATP = 6;
Rx_4mer_ADP = 7;
Rx_4mer_ATP = 8;
Rx_5mer_ADP = 9;
Rx_5mer_ATP = 10;
Rx_6mer_ADP = 11;
Rx_6mer_ATP = 12;
Rx_7mer_ADP = 13;
Rx_7mer_ATP = 14;

//TODO: check this
cSite = 70;
cState = 20;


# calculate ATP complex size (necessary for cooperativity & polymerization rates)
var sizeR1_ATP, sizeR2_ATP, sizeR3_ATP, sizeR4_ATP;
sizeR1_ATP = piecewise( chromosome_R1 / 2, mod( chromosome_R1, 2 ) == 0, floor( chromosome_R1 / 2 ) - 1 );
sizeR2_ATP = piecewise( chromosome_R2 / 2, mod( chromosome_R2, 2 ) == 0, floor( chromosome_R2 / 2 ) - 1 );
sizeR3_ATP = piecewise( chromosome_R3 / 2, mod( chromosome_R3, 2 ) == 0, floor( chromosome_R3 / 2 ) - 1 );
sizeR4_ATP = piecewise( chromosome_R4 / 2, mod( chromosome_R4, 2 ) == 0, floor( chromosome_R4 / 2 ) - 1 );
# calculate cooperativity
var complexSize = minFunc(sizeR1_ATP, minFunc(sizeR2_ATP, minFunc(sizeR3_ATP, sizeR4_ATP) ) );
var coopR1, coopR2, coopR3, coopR4;
coopR1 = piecewise(cSite, sizeR4_ATP > complexSize, 1);
coopR2 = piecewise(cSite, sizeR4_ATP > complexSize && sizeR1_ATP > complexSize, 1);
coopR3 = piecewise(cSite, sizeR4_ATP > complexSize && sizeR1_ATP > complexSize, 1);
coopR4 = piecewise(cSite, sizeR3_ATP > complexSize || sizeR2_ATP > complexSize || sizeR1_ATP > complexSize, 1) + cState * complexSize;
################################################################################################################################################
################################################################# ATP part #####################################################################
################################################################################################################################################
############################################ 1. Check DnaA_1mer_ATP availability ###############################################################
numFreeDnaAATP = MG_469_1MER_ATP__c;
//TODO

################################################################################################################################################
############################################ 2. Estimate max number of bindings ################################################################
var avgBindingRateATP, rate9merBindATP, rate8merBindATP;
nAvo := 6.0221412927*1e23;
kb1ATP := 25;
kb2ATP := 0.6;
rate9merBindATP := kb1ATP * 1e9 / 3600 / nAvo / cell_Volume;
rate8merBindATP := kb2ATP * 1e9 / 3600 / nAvo / cell_Volume;

// TODO: use real values of unbind 9mer and 8mer numbers instead of hardcoded constants
avgBindingRateATP := ( 148 * rate9merBindATP + 2079 * rate8merBindATP ) / (2227 - MG_469_1MER_ADP__bound - MG_469_1MER_ATP__bound);
// avgBindingRate = (rate9mer*numel(this.dnaABoxIndexs_9mer) + rate8mer*numel(this.dnaABoxIndexs_8mer)) / numel(this.dnaABoxStartPositions);

# calculate R1-R4 binding rates
var bindRateR4ATP, bindRateR1ATP, bindRateR2ATP, bindRateR3ATP;
bindRateR4ATP = rate9merBindATP * coopR4;
bindRateR1ATP = rate8merBindATP * coopR1;
bindRateR2ATP = rate8merBindATP * coopR2;
bindRateR3ATP = rate8merBindATP * coopR3;

var numFreeBindingSitesATP;
numFreeBindingSitesATP = 2227 - MG_469_1MER_ATP__bound + 4 - piecewise(1, chromosome_R1 > 0, 0) - piecewise(1, chromosome_R2 > 0, 0) - piecewise(1, chromosome_R3 > 0, 0) - piecewise(1, chromosome_R4 > 0, 0);

var maxBindATP, areReady;
areReady = piecewise(1, sizeR1_ATP + sizeR2_ATP + sizeR3_ATP + sizeR4_ATP == 28, 0);
maxBindATP = stochasticRound( minFunc( avgBindingRateATP * numFreeBindingSitesATP * numFreeDnaAATP + areReady, minFunc( numFreeBindingSitesATP, numFreeDnaAATP ) ) );


################################################################################################################################################
############################################ 3. Estimate upper bound of polymerization #########################################################
var canStartPol;
canStartPol = piecewise( 1, complexSize > 0, 0 );

var polRange;
polRange = minFunc( 6, maxFunc( 1, complexSize ) );
var polRateR4, polRateR1, polRateR2, polRateR3, totPolRate;
polRateR4 = piecewise( rate9merBindATP * coopR4, sizeR4_ATP == polRange, 0 );
polRateR1 = piecewise( rate8merBindATP * coopR1, sizeR1_ATP == polRange, 0 );
polRateR2 = piecewise( rate8merBindATP * coopR2, sizeR2_ATP == polRange, 0 );
polRateR3 = piecewise( rate8merBindATP * coopR3, sizeR3_ATP == polRange, 0 );
totPolRate = polRateR1 + polRateR2 + polRateR3 + polRateR4;
var numFreePolSites;
numFreePolSites = piecewise( 1, polRateR1 > 0, 0 ) + piecewise( 1, polRateR2 > 0, 0 ) + piecewise( 1, polRateR3 > 0, 0 ) + piecewise( 1, polRateR4 > 0, 0 );

var maxPolATP;
maxPolATP = stochasticRound( minFunc( numFreeDnaAATP*totPolRate, minFunc( numFreePolSites, numFreeDnaAATP ) ) );


################################################################################################################################################
############################################ 4. Allocate DnaA-ATP ##############################################################################
var totBindingRateATP, maxBindingATP;
totBindingRateATP = avgBindingRateATP*numFreeBindingSitesATP;
maxBindingATP = minFunc( maxBindATP, stochasticRound( numFreeDnaAATP * totBindingRateATP / ( totBindingRateATP + totPolRate ) ) );


################################################################################################################################################
############################################ 5. Bind and Polymerize ############################################################################
//TODO

default is "BindAndPolymerization";
end